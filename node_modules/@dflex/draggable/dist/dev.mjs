class Point {
  constructor(x, y) {
    this.setAxes(x, y);
  }
  setAxes(x, y) {
    this.x = x;
    this.y = y;
  }
  clone(target) {
    this.setAxes(target.x, target.y);
  }
  getInstance() {
    return {
      x: this.x,
      y: this.y
    };
  }
  isEqual(target) {
    return this.x === target.x && this.y === target.y;
  }
}

class PointNum extends Point {
  increase(point) {
    this.x += point.x;
    this.y += point.y;
  }
  decrease(point) {
    this.x -= point.x;
    this.y -= point.y;
  }
  multiplyAll(val) {
    this.x *= val;
    this.y *= val;
  }
  getMultiplied(val) {
    return { x: this.x * val, y: this.y * val };
  }
}

function combineKeys(k1, k2) {
  return `${k1}-${k2}`;
}

function getSelection() {
  return window.getSelection();
}

class Generator {
  constructor() {
    this.indicator = {};
    this.branches = {};
    this.branchesByDepth = {};
    this.prevDepth = -99;
    this.prevKey = combineKeys(0, 0);
  }
  initIndicators(dp) {
    if (this.indicator[dp] === void 0) {
      this.indicator[dp] = -1;
    }
    if (this.indicator[dp + 1] === void 0) {
      this.indicator[dp + 1] = 0;
    }
    if (this.indicator[dp + 2] === void 0) {
      this.indicator[dp + 2] = 0;
    }
  }
  addElementIDToDepthCollection(SK, depth) {
    if (!Array.isArray(this.branchesByDepth[depth])) {
      this.branchesByDepth[depth] = [SK];
      return;
    }
    const is = this.branchesByDepth[depth].find((k) => k === SK);
    if (!is) {
      this.branchesByDepth[depth].push(SK);
    }
  }
  addElementIDToSiblingsBranch(id, SK) {
    if (!Array.isArray(this.branches[SK])) {
      this.branches[SK] = [];
    }
    const selfIndex = this.branches[SK].push(id) - 1;
    return selfIndex;
  }
  getElmBranch(SK) {
    return this.branches[SK];
  }
  accumulateIndicators(depth) {
    if (depth !== this.prevDepth) {
      this.initIndicators(depth);
    }
    const parentIndex = this.indicator[depth + 1];
    const SK = combineKeys(depth, parentIndex);
    const PK = combineKeys(depth + 1, this.indicator[depth + 2]);
    const CHK = depth === 0 ? null : this.prevKey;
    this.prevKey = SK;
    this.indicator[depth] += 1;
    if (depth < this.prevDepth) {
      this.indicator[0] = 0;
    }
    this.prevDepth = depth;
    return {
      CHK,
      SK,
      PK,
      parentIndex
    };
  }
  register(id, depth) {
    const { CHK, SK, PK, parentIndex } = this.accumulateIndicators(depth);
    this.addElementIDToDepthCollection(SK, depth);
    const selfIndex = this.addElementIDToSiblingsBranch(id, SK);
    const keys = {
      SK,
      PK,
      CHK
    };
    const order = {
      self: selfIndex,
      parent: parentIndex
    };
    return { order, keys };
  }
  removeElementIDFromBranch(SK, index) {
    let deletedElmID;
    if (Array.isArray(this.branches[SK]) && this.branches[SK][index] !== void 0) {
      [deletedElmID] = this.branches[SK].splice(index, 1);
      if (this.branches[SK].length === 0) {
        delete this.branches[SK];
      }
      return deletedElmID;
    }
    return null;
  }
  destroyBranch(SK, cb) {
    if (!this.branches[SK])
      return;
    const elmID = this.branches[SK].pop();
    if (!elmID)
      return;
    cb(elmID);
    if (this.branches[SK].length > 0) {
      this.destroyBranch(SK, cb);
    } else {
      delete this.branches[SK];
    }
    Object.keys(this.branchesByDepth).forEach((dp) => {
      const dpNum = Number(dp);
      this.branchesByDepth[dpNum] = this.branchesByDepth[dpNum].filter((key) => key !== SK);
      if (this.branchesByDepth[dpNum].length === 0) {
        delete this.branchesByDepth[dpNum];
      }
    });
  }
  destroy() {
    [
      "branches",
      "branchesByDepth",
      "branchesOrder",
      "branchesByDepth",
      "indicator"
    ].forEach((key) => {
      this[key] = null;
    });
  }
}

class DFlexBaseNode {
  constructor(id, opts) {
    this.id = id;
    if (opts.isInitialized) {
      this.attach();
      this.isPaused = opts.isPaused;
      if (!this.isPaused) {
        this.initTranslate();
      }
      return;
    }
    this.isInitialized = false;
    this.ref = null;
    this.isPaused = true;
  }
  attach() {
    this.ref = document.getElementById(this.id);
    {
      if (!this.ref) {
        throw new Error(`Attach: Element with ID: ${this.id} is not found.`);
      }
      if (this.ref.nodeType !== Node.ELEMENT_NODE) {
        throw new Error(`Attach: Invalid HTMLElement ${this.ref} is passed to registry.`);
      }
    }
    this.isInitialized = true;
  }
  detach() {
    this.isInitialized = false;
    this.ref = null;
  }
  transform(x, y) {
    this.ref.style.transform = `translate3d(${x}px,${y}px, 0)`;
  }
  initTranslate() {
    if (!this.translate) {
      this.translate = new PointNum(0, 0);
      this._hasAttribute = {};
    }
    this.isPaused = false;
  }
  setDataset(key, value) {
    if (key === "index" || key === "gridX" || key === "gridY") {
      this.ref.dataset[key] = `${value}`;
      return;
    }
    if (this._hasAttribute[key])
      return;
    this.ref.dataset[key] = `${value}`;
    this._hasAttribute[key] = true;
  }
  rmDateset(key) {
    delete this.ref.dataset[key];
    if (this._hasAttribute[key]) {
      this._hasAttribute[key] = false;
    }
  }
  setAttribute(key, value) {
    if (this._hasAttribute[key])
      return;
    this.ref.setAttribute(key, value);
    this._hasAttribute[key] = true;
  }
  removeAttribute(key) {
    if (!this._hasAttribute[key])
      return;
    this.ref.removeAttribute(key);
    this._hasAttribute[key] = false;
  }
  clearAttributes() {
    Object.keys(this._hasAttribute).forEach((key) => {
      if (key === "dragged")
        this.removeAttribute(key);
      else
        this.rmDateset(key);
    });
    this._hasAttribute = {};
  }
}

class DFlexCoreNode extends DFlexBaseNode {
  constructor(eleWithPointer, opts) {
    const { order, keys, depth, scrollX, scrollY, readonly, id } = eleWithPointer;
    super(id, opts);
    this.order = order;
    this.keys = keys;
    this.depth = depth;
    this.readonly = readonly;
    this.isVisible = this.isInitialized && !this.isPaused;
    if (this.isInitialized) {
      this.setDataset("index", this.order.self);
    }
    if (!this.isPaused) {
      this._initIndicators(scrollX, scrollY);
    }
    this.animatedFrame = null;
  }
  _initIndicators(scrollX, scrollY) {
    const { height, width, left, top } = this.ref.getBoundingClientRect();
    this.offset = {
      height,
      width,
      left: left + scrollX,
      top: top + scrollY
    };
    this.currentPosition = new PointNum(this.offset.left, this.offset.top);
    this.grid = new PointNum(0, 0);
    this.hasToTransform = false;
  }
  _updateCurrentIndicators(space) {
    this.translate.increase(space);
    const { left, top } = this.offset;
    this.currentPosition.setAxes(left + this.translate.x, top + this.translate.y);
    if (!this.isVisible)
      this.hasToTransform = true;
  }
  resume(scrollX, scrollY) {
    if (!this.isInitialized)
      this.attach();
    this.initTranslate();
    this._initIndicators(scrollX, scrollY);
  }
  changeVisibility(isVisible) {
    if (isVisible === this.isVisible)
      return;
    this.isVisible = isVisible;
    if (this.hasToTransform && this.isVisible) {
      this.transformElm();
      this.hasToTransform = false;
    }
  }
  transformElm() {
    if (this.animatedFrame !== null) {
      window.cancelAnimationFrame(this.animatedFrame);
    }
    this.animatedFrame = window.requestAnimationFrame(() => {
      this.transform(this.translate.x, this.translate.y);
      this.animatedFrame = null;
    });
  }
  _updateOrderIndexing(i) {
    const { self: oldIndex } = this.order;
    const newIndex = oldIndex + i;
    this.order.self = newIndex;
    this.setDataset("index", newIndex);
    return { oldIndex, newIndex };
  }
  assignNewPosition(branchIDsOrder, newIndex) {
    if (newIndex < 0 || newIndex > branchIDsOrder.length - 1) {
      {
        console.error(`Illegal Attempt: Received an index:${newIndex} on siblings list:${branchIDsOrder.length - 1}.
`);
      }
      return;
    }
    if (branchIDsOrder[newIndex].length > 0) {
      {
        console.error("Illegal Attempt: Colliding in positions.\n", `Element id: ${this.id}
`, `Collided at index: ${newIndex}
`, `Siblings list: ${branchIDsOrder}
`);
      }
      return;
    }
    branchIDsOrder[newIndex] = this.id;
  }
  _leaveToNewPosition(branchIDsOrder, newIndex, oldIndex) {
    branchIDsOrder[oldIndex] = "";
    branchIDsOrder[newIndex] = this.id;
  }
  _seTranslate(elmSpace, axis, operationID, isForceTransform = false) {
    if (operationID) {
      const elmAxesHistory = {
        ID: operationID,
        axis,
        translate: { x: this.translate.x, y: this.translate.y }
      };
      if (!Array.isArray(this._translateHistory)) {
        this._translateHistory = [elmAxesHistory];
      } else {
        this._translateHistory.push(elmAxesHistory);
      }
    }
    this._updateCurrentIndicators(elmSpace);
    if (!isForceTransform && !this.isVisible) {
      this.hasToTransform = true;
      return;
    }
    this.transformElm();
    this.hasToTransform = false;
  }
  setPosition(iDsInOrder, direction, elmSpace, operationID, axis) {
    const numberOfPassedElm = 1;
    if (axis === "z") {
      elmSpace.multiplyAll(direction);
    } else {
      elmSpace[axis] *= direction;
    }
    this._seTranslate(elmSpace, axis, operationID);
    const { oldIndex, newIndex } = this._updateOrderIndexing(direction * numberOfPassedElm);
    if (axis === "z") {
      const inc = direction * numberOfPassedElm;
      this.grid.increase({ x: inc, y: inc });
    } else {
      this.grid[axis] += direction * numberOfPassedElm;
      {
        this.setDataset(`grid${axis.toUpperCase()}`, this.grid[axis]);
      }
    }
    this._leaveToNewPosition(iDsInOrder, newIndex, oldIndex);
  }
  rollBack(operationID, isForceTransform) {
    if (!Array.isArray(this._translateHistory) || this._translateHistory.length === 0 || this._translateHistory[this._translateHistory.length - 1].ID !== operationID) {
      return;
    }
    const lastMovement = this._translateHistory.pop();
    const { translate: preTranslate, axis } = lastMovement;
    const elmSpace = {
      x: preTranslate.x - this.translate.x,
      y: preTranslate.y - this.translate.y
    };
    let increment = 0;
    if (axis === "z") {
      increment = elmSpace.x > 0 || elmSpace.y > 0 ? 1 : -1;
      this.grid.increase({ x: increment, y: increment });
    } else {
      increment = elmSpace[axis] > 0 ? 1 : -1;
      this.grid[axis] += increment;
      {
        this.setDataset(`grid${axis.toUpperCase()}`, this.grid[axis]);
      }
    }
    this._seTranslate(elmSpace, axis, void 0, isForceTransform);
    this._updateOrderIndexing(increment);
    this.rollBack(operationID, isForceTransform);
  }
}

class DFlexNode extends DFlexCoreNode {
  static getRectByAxis(axis) {
    return axis === "x" ? "width" : "height";
  }
  static getDistance(currentPosition, elm, axis) {
    let diff = currentPosition[axis] - elm.currentPosition[axis];
    diff += elm.translate[axis];
    return diff;
  }
  static getDisplacement(currentPosition, elm, axis) {
    const diff = axis === "x" ? elm.getRectRight() : elm.getRectBottom();
    return currentPosition[axis] - diff;
  }
  isConnected() {
    return this.ref.isConnected;
  }
  isPositionedUnder(elmY) {
    return elmY <= this.currentPosition.y;
  }
  isPositionedLeft(elmX) {
    return elmX <= this.currentPosition.x;
  }
  hasSamePosition(elm, axis) {
    return this.currentPosition[axis] === elm.currentPosition[axis];
  }
  getRectBottom() {
    return this.currentPosition.y + this.offset.height;
  }
  getRectRight() {
    return this.currentPosition.x + this.offset.width;
  }
  getRectDiff(elm, axis) {
    const rectType = DFlexNode.getRectByAxis(axis);
    return this.offset[rectType] - elm.offset[rectType];
  }
  getDisplacement(elm, axis) {
    return DFlexNode.getDisplacement(this.currentPosition, elm, axis);
  }
  getDistance(elm, axis) {
    return DFlexNode.getDistance(this.currentPosition, elm, axis);
  }
  getOffset() {
    return {
      width: this.offset.width,
      height: this.offset.height,
      top: this.currentPosition.y,
      left: this.currentPosition.x
    };
  }
}

class DFlexBaseStore {
  constructor() {
    this._lastKeyIdentifier = null;
    this.registry = {};
    this.DOMGen = new Generator();
  }
  _submitElementToRegistry(element) {
    const { id, depth, isPaused, isInitialized, ...rest } = element;
    const { order, keys } = this.DOMGen.register(id, depth);
    const coreElement = {
      id,
      order,
      keys,
      depth,
      ...rest
    };
    this.registry[id] = new DFlexNode(coreElement, {
      isInitialized,
      isPaused
    });
  }
  register(element) {
    if (!this._lastKeyIdentifier || element.parentID === this._lastKeyIdentifier) {
      this._lastKeyIdentifier = element.parentID;
      this._submitElementToRegistry(element);
      return;
    }
    const { parentID, depth } = element;
    this.DOMGen.register(parentID, depth + 1);
    this._submitElementToRegistry(element);
  }
  getElmBranchByKey(SK) {
    return this.DOMGen.getElmBranch(SK);
  }
  unregister(id) {
    delete this.registry[id];
  }
  destroyBranch(SK) {
    this.DOMGen.destroyBranch(SK, (id) => {
      this.unregister(id);
    });
  }
  destroy() {
    Object.keys(this.DOMGen.branches).forEach((SK) => {
      this.DOMGen.destroyBranch(SK, (id) => {
        delete this.registry[id];
      });
    });
    this.DOMGen.destroy();
  }
}

class DraggableStoreImp extends DFlexBaseStore {
  register(id) {
    super.register({
      id,
      depth: 0,
      parentID: "",
      isInitialized: true,
      isPaused: false,
      scrollX: 0,
      scrollY: 0,
      readonly: false
    });
  }
}
var store = (function createStoreInstance() {
  const store = new DraggableStoreImp();
  return store;
})();

const _AbstractDraggable = class {
  constructor(abstractCoreElm, { x: initX, y: initY }) {
    this.draggedElm = abstractCoreElm;
    const { translate } = this.draggedElm;
    this.outerOffset = new PointNum(-initX + translate.x, -initY + translate.y);
    this.translatePlaceholder = new PointNum(0, 0);
    this.setDragged(true);
  }
  changeStyle(style, shouldAddPosition) {
    if (shouldAddPosition) {
      style.forEach(({ prop, dragValue }) => {
        this.draggedElm.ref.style[prop] = dragValue;
      });
      return;
    }
    style.forEach(({ prop, afterDragValue }) => {
      this.draggedElm.ref.style[prop] = afterDragValue;
    });
  }
  setDragged(isActive) {
    if (isActive) {
      this.changeStyle(_AbstractDraggable.draggedStyle, true);
      const domSelection = getSelection();
      if (domSelection) {
        domSelection.removeAllRanges();
      }
      this.draggedElm.setAttribute("dragged", "true");
      return;
    }
    this.changeStyle(_AbstractDraggable.draggedStyle, false);
    this.draggedElm.clearAttributes();
  }
  translate(x, y) {
    this.translatePlaceholder.setAxes(x + this.outerOffset.x, y + this.outerOffset.y);
    this.draggedElm.transform(this.translatePlaceholder.x, this.translatePlaceholder.y);
  }
};
let AbstractDraggable = _AbstractDraggable;
AbstractDraggable.draggedStyle = [
  {
    prop: "position",
    dragValue: "relative",
    afterDragValue: ""
  },
  {
    prop: "zIndex",
    dragValue: "99",
    afterDragValue: ""
  },
  {
    prop: "user-select",
    dragValue: "none",
    afterDragValue: ""
  }
];

class Draggable extends AbstractDraggable {
  constructor(id, clickCoordinates) {
    const element = store.registry[id];
    super(element, clickCoordinates);
  }
  dragAt(x, y) {
    this.translate(x, y);
    this.draggedElm.translate.clone(this.translatePlaceholder);
  }
  endDragging() {
    this.setDragged(false);
  }
}

export { AbstractDraggable, Draggable, store };
