import type { IDFlexBaseNode } from "@dflex/core-instance";
import type { IPointNum, IPointAxes } from "@dflex/utils";
import type { IAbstractDraggable, DraggedStyle } from "./types";
declare class AbstractDraggable<T extends IDFlexBaseNode> implements IAbstractDraggable<T> {
    draggedElm: T;
    /**
     * When dragging start, element shouldn't jump from its translate. So, we
     * calculate offset that make translate X,Y start from zero:
     *  goToX = x + this.outerOffsetX.
     *  goToY = y + this.outerOffsetY.
     *
     * goToX and goToY both should be zero with first click. Starts with simple
     * equating: initX = X. Taking into considerations translate value.
     *
     */
    outerOffset: IPointNum;
    translatePlaceholder: IPointNum;
    static draggedStyle: DraggedStyle;
    /**
     * Creates an instance of AbstractDraggable.
     * Works Only on dragged element level.
     *
     * @param abstractCoreElm -
     * @param initCoordinates -
     */
    constructor(abstractCoreElm: T, { x: initX, y: initY }: IPointAxes);
    changeStyle(style: DraggedStyle, shouldAddPosition: boolean): void;
    /**
     * Triggers twice. Once when constructor is initiated, the other when drag is
     * ended. It adds/removes style.
     *
     * @param isActive - is dragged operation active or it is ended.
     */
    protected setDragged(isActive: boolean): void;
    /**
     * Executes dragging by applying transform.
     * Writes to draggedElmCurrentOffset in Transform class.
     * Set values to isDragged flags.
     *
     * @param x - mouse x coordinates
     * @param y - mouse y coordinates
     */
    protected translate(x: number, y: number): void;
}
export default AbstractDraggable;
